# 多版本EchoServer
借助poll()函数实现单进程单线程方式，可以同时服务多个客户端的并发回显服务器
借助poll函数能并发处理的原因是：poll阻塞进程时，可以获取到多个IO的事件 -- 之前不管是accept()还是recv()阻塞都是等待一个指定socket事件，比如recv()阻塞时，监听套接字不会觉察到连接事件，而采用poll阻塞进程时，每个socket有事件发生时都能知道，poll函数返回之后可以顺序的处理所发生的事件，这就是所谓的IO复用。

如何处理accept()函数出错时的EMFILE错误
该错误是进程的文件描述达到了上限，此时不能再给要连接的客户端分配一个连接套接字connfd了

显然这个错误发生时不可能让程序退出，因为这只是暂时性的资源不足，随着客户端断开连接，服务器端就又有了空闲的文件描述符了，此时就可以正常的处理客户端的连接了
如果程序不退出，因为accept()没有成功，监听套接字的可读事件依旧存在，下一次还是会触发调用accept()，此时又出现了EMFILE错误，这就是如果不对这种情况进行处理的话，服务器会进入busy-loop
所以必须要处理该错误，处理方式有如下几种：
* 调高进程文件描述符的数目 -- 如何调高？？这种方式随着连接的增加，还是会出现EMFILE错误
* 关闭监听套接字，关闭了监听套接字那么就不会再触发其可读事件了，但是问题是什么时候再打开监听套接字呢？如果监听套接字不打开的话，客户端就没法连接了
* 最优的解决方案是：实现预留一个文件描述符，当出现EMFILE错误时，关闭预留的文件描述符，这样进程就有了一个空闲的描述符，此时再次调用accept()，这样就能成功的接受一个客户端的连接，而且监听套接字的可读事件也不存在了（调用poll是不会再触发，解决了busy-loop）
问题是如果又有一个连接连入时，不就又会出现EMFILE错误，而此时也没有了预留的文件描述符了，不就又进入的busy-loop
所以，在accpet接受连接之后立刻调用close()关闭连接，这样客户端也不会出现问题（会经历完整的四次挥手），之后再预留一个文件描述符，以备处理下一次发生EMFILE错误
处理代码见上面的代码